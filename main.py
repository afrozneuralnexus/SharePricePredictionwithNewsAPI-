# -*- coding: utf-8 -*-
"""maineeeee

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VE_i_wPNbVFVKWW6l9-H292M7WMpXXD_
"""

# -*- coding: utf-8 -*-
"""maineee

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LZtaPQHPI2PQCYMJ0MYmCa0kwdUAxmwf
"""

import yfinance as yf
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import requests
from textblob import TextBlob
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
import streamlit as st
import warnings
warnings.filterwarnings('ignore')

# Sector-wise stocks
SECTORS = {
    "Information Technology (IT) & Services": [
        "TCS.NS", "INFY.NS", "HCLTECH.NS", "WIPRO.NS", "TECHM.NS"
    ],
    "Banking & Financial Services": [
        "HDFCBANK.NS", "ICICIBANK.NS", "SBIN.NS", "KOTAKBANK.NS",
        "AXISBANK.NS", "BAJFINANCE.NS", "HDFCLIFE.NS", "ICICIPRULI.NS"
    ],
    "Conglomerates & Industrial": [
        "RELIANCE.NS", "LT.NS", "TATAMOTORS.NS", "TATASTEEL.NS", "M&M.NS"
    ],
    "Consumer Goods & Telecom": [
        "ITC.NS", "HINDUNILVR.NS", "BRITANNIA.NS", "BHARTIARTL.NS", "MARUTI.NS"
    ],
    "Energy & Commodities": [
        "ONGC.NS", "NTPC.NS", "COALINDIA.NS", "HINDALCO.NS", "JSWSTEEL.NS"
    ]
}

NEWS_API_KEY = "6b4efd22e1b4433488adb20e81814840"

class StockSentimentAnalyzer:
    def __init__(self, ticker, news_api_key):
        self.ticker = ticker
        self.news_api_key = news_api_key
        self.stock_data = None
        self.news_sentiment = None
        self.news_articles = []
        self.model = None
        self.scaler = None

    def fetch_stock_data(self, start_date, end_date):
        """Fetch historical stock data"""
        stock = yf.Ticker(self.ticker)
        self.stock_data = stock.history(start=start_date, end=end_date)
        return self.stock_data

    def get_company_name(self):
        """Get company name from ticker"""
        try:
            stock = yf.Ticker(self.ticker)
            info = stock.info
            company_name = info.get('longName', self.ticker.replace('.NS', ''))
            # Simplify company name for better news search
            company_name = company_name.replace('Limited', '').replace('Ltd', '').strip()
            return company_name
        except:
            return self.ticker.replace('.NS', '')

    def fetch_news(self, days_back=30):
        """Fetch 20 most recent news articles about the stock"""
        company_name = self.get_company_name()
        ticker_short = self.ticker.replace('.NS', '')

        end_date = datetime.now()
        start_date = end_date - timedelta(days=days_back)

        url = "https://newsapi.org/v2/everything"
        params = {
            'q': f'({company_name} OR {ticker_short}) AND (stock OR share OR market)',
            'from': start_date.strftime('%Y-%m-%d'),
            'to': end_date.strftime('%Y-%m-%d'),
            'language': 'en',
            'sortBy': 'publishedAt',
            'pageSize': 20,  # Get 20 most recent articles
            'apiKey': self.news_api_key
        }

        try:
            response = requests.get(url, params=params, timeout=15)
            news_data = response.json()

            if news_data.get('status') == 'ok':
                articles = news_data.get('articles', [])

                if len(articles) == 0:
                    st.warning(f"No news articles found for {company_name}. Trying alternative search...")
                    # Try with just ticker
                    params['q'] = ticker_short
                    response = requests.get(url, params=params, timeout=15)
                    news_data = response.json()
                    articles = news_data.get('articles', [])

                if len(articles) > 0:
                    st.success(f"âœ… Found {len(articles)} news articles for {company_name}")
                    self.news_articles = articles[:20]  # Ensure we have max 20
                    return self._analyze_sentiment(articles[:20])
                else:
                    st.error(f"âŒ No news articles found for {company_name}. Cannot proceed with analysis.")
                    return None
            else:
                error_msg = news_data.get('message', 'Unknown error')
                st.error(f"âŒ NewsAPI Error: {error_msg}")
                return None

        except Exception as e:
            st.error(f"âŒ Error fetching news: {str(e)}")
            return None

    def _analyze_sentiment(self, articles):
        """Analyze sentiment of news articles"""
        sentiment_data = []

        for article in articles:
            title = article.get('title', '')
            description = article.get('description', '')
            text = f"{title} {description}"

            # Perform sentiment analysis
            blob = TextBlob(text)
            sentiment_score = blob.sentiment.polarity

            try:
                pub_date = datetime.strptime(article['publishedAt'][:10], '%Y-%m-%d').date()
            except:
                pub_date = datetime.now().date()

            sentiment_data.append({
                'date': pub_date,
                'sentiment_score': sentiment_score,
                'title': title,
                'description': description,
                'url': article.get('url', ''),
                'source': article.get('source', {}).get('name', 'Unknown'),
                'publishedAt': article.get('publishedAt', '')
            })

        # Create DataFrame
        sentiment_df = pd.DataFrame(sentiment_data)

        # Aggregate by date for merging with stock data
        sentiment_agg = sentiment_df.groupby('date').agg({
            'sentiment_score': 'mean',
            'title': 'count'
        }).reset_index()
        sentiment_agg.columns = ['date', 'sentiment_score', 'article_count']

        return sentiment_agg

    def prepare_features(self):
        """Prepare features for prediction model"""
        df = self.stock_data.copy()
        df = df.reset_index()

        # Calculate technical indicators
        df['Returns'] = df['Close'].pct_change()
        df['MA_5'] = df['Close'].rolling(window=5).mean()
        df['MA_20'] = df['Close'].rolling(window=20).mean()
        df['MA_50'] = df['Close'].rolling(window=50).mean()
        df['Volatility'] = df['Returns'].rolling(window=20).std()
        df['RSI'] = self._calculate_rsi(df['Close'])

        # Create date column for merging
        df['merge_date'] = pd.to_datetime(df['Date']).dt.date

        # Ensure sentiment dates are in correct format
        sentiment_df = self.news_sentiment.copy()
        sentiment_df['date'] = pd.to_datetime(sentiment_df['date']).dt.date

        # Merge with sentiment data
        df = df.merge(sentiment_df, left_on='merge_date', right_on='date', how='left')

        # Forward fill sentiment scores (use previous sentiment for days without news)
        df['sentiment_score'] = df['sentiment_score'].fillna(method='ffill').fillna(0)
        df['article_count'] = df['article_count'].fillna(0)

        # Create target (next day's return)
        df['Target'] = df['Returns'].shift(-1)

        # Drop NaN values
        df = df.dropna()

        return df

    def _calculate_rsi(self, prices, period=14):
        """Calculate Relative Strength Index"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi

    def train_model(self):
        """Train prediction model"""
        df = self.prepare_features()

        # Check if we have enough data for training
        if len(df) < 50:
            st.warning(f"âš ï¸ Insufficient data for model training. Only {len(df)} data points available. Need at least 50.")
            return None, None, False

        features = ['Returns', 'MA_5', 'MA_20', 'Volatility', 'RSI',
                   'sentiment_score', 'article_count', 'Volume']

        X = df[features]
        y = df['Target']

        # Use smaller test size if data is limited
        test_size = min(0.2, 10/len(X))  # Ensure at least 10 samples in test set

        try:
            X_train, X_test, y_train, y_test = train_test_split(
                X, y, test_size=test_size, random_state=42, shuffle=False
            )
        except ValueError as e:
            st.error(f"âŒ Not enough data for train-test split: {str(e)}")
            return None, None, False

        # Check if we have enough training data
        if len(X_train) < 30:
            st.warning(f"âš ï¸ Limited training data ({len(X_train)} samples). Model may not be accurate.")
            # Use all data for training
            X_train, X_test, y_train, y_test = X, X, y, y
            test_score = None
        else:
            self.scaler = StandardScaler()
            X_train_scaled = self.scaler.fit_transform(X_train)
            X_test_scaled = self.scaler.transform(X_test)

            self.model = RandomForestRegressor(n_estimators=100, random_state=42, n_jobs=-1)
            self.model.fit(X_train_scaled, y_train)

            train_score = self.model.score(X_train_scaled, y_train)
            test_score = self.model.score(X_test_scaled, y_test)

            return train_score, test_score, True

        # Fallback: train on all data
        self.scaler = StandardScaler()
        X_scaled = self.scaler.fit_transform(X)

        self.model = RandomForestRegressor(n_estimators=100, random_state=42, n_jobs=-1)
        self.model.fit(X_scaled, y)

        train_score = self.model.score(X_scaled, y)
        return train_score, None, True

    def predict_next_day(self):
        """Predict next day's return"""
        if self.model is None:
            return 0, self.stock_data['Close'].iloc[-1], self.stock_data['Close'].iloc[-1]

        df = self.prepare_features()

        features = ['Returns', 'MA_5', 'MA_20', 'Volatility', 'RSI',
                   'sentiment_score', 'article_count', 'Volume']
        latest_data = df[features].iloc[-1:].values

        latest_scaled = self.scaler.transform(latest_data)
        prediction = self.model.predict(latest_scaled)[0]

        current_price = self.stock_data['Close'].iloc[-1]
        predicted_price = current_price * (1 + prediction)

        return prediction, current_price, predicted_price


# Streamlit App
def main():
    st.set_page_config(page_title="Indian Stock Sentiment Analyzer", page_icon="ğŸ“ˆ", layout="wide")

    st.title("ğŸ“ˆ Indian Stock Market Sentiment & Price Analyzer")
    st.markdown("**AI-Powered Stock Analysis with Real-Time News Sentiment**")

    # Sidebar
    with st.sidebar:
        st.image("https://upload.wikimedia.org/wikipedia/commons/3/3a/Stock_market_icon.png", width=180)
        st.header("ğŸ›ï¸ Analysis Settings")

        sector = st.selectbox("ğŸ“Š Select Sector", list(SECTORS.keys()))
        ticker = st.selectbox("ğŸ¢ Select Stock", SECTORS[sector])

        st.markdown("---")
        st.subheader("ğŸ“… Date Range")
        start_date = st.date_input("Start Date", datetime.now() - timedelta(days=365))
        end_date = st.date_input("End Date", datetime.now())

        st.markdown("---")
        st.subheader("ğŸ“° News Settings")
        news_days = st.slider("News History (days)", 7, 60, 30)

        st.markdown("---")
        analyze_button = st.button("ğŸš€ Analyze Stock", type="primary", use_container_width=True)

    if analyze_button:
        if start_date >= end_date:
            st.error("âŒ Start date must be before end date")
            return

        try:
            with st.spinner(f"ğŸ” Analyzing {ticker}..."):
                # Initialize analyzer
                analyzer = StockSentimentAnalyzer(ticker, NEWS_API_KEY)
                company_name = analyzer.get_company_name()

                # Fetch stock data
                st.info(f"ğŸ“Š Fetching stock data for {company_name}...")
                stock_data = analyzer.fetch_stock_data(start_date, end_date)

                if len(stock_data) == 0:
                    st.error("âŒ No stock data found for the selected date range")
                    return

                # Fetch news (MANDATORY)
                st.info(f"ğŸ“° Fetching 20 most recent news articles...")
                analyzer.news_sentiment = analyzer.fetch_news(days_back=news_days)

                # Check if news fetching was successful
                if analyzer.news_sentiment is None or len(analyzer.news_articles) == 0:
                    st.error("âŒ News analysis is mandatory. Cannot proceed without news data. Please try a different stock or check your internet connection.")
                    return

                # Train model
                st.info("ğŸ¤– Training prediction model...")
                train_score, test_score, model_trained = analyzer.train_model()

                if not model_trained:
                    st.error("âŒ Model training failed due to insufficient data. Please select a longer date range.")
                    return

                # Get prediction
                predicted_return, current_price, predicted_price = analyzer.predict_next_day()

                st.success("âœ… Analysis Complete!")

                # Display results
                st.markdown("---")
                st.header(f"ğŸ“Š Analysis Results: {company_name} ({ticker})")

                # Metrics
                col1, col2, col3, col4, col5 = st.columns(5)

                with col1:
                    st.metric("Current Price", f"â‚¹{current_price:.2f}")

                with col2:
                    if len(stock_data) > 1:
                        price_change = ((current_price - stock_data['Close'].iloc[-2]) / stock_data['Close'].iloc[-2]) * 100
                        st.metric("24h Change", f"{price_change:+.2f}%", delta=f"{price_change:+.2f}%")
                    else:
                        st.metric("24h Change", "N/A")

                with col3:
                    avg_sentiment = analyzer.news_sentiment['sentiment_score'].mean()
                    sentiment_emoji = "ğŸŸ¢" if avg_sentiment > 0.1 else "ğŸ”´" if avg_sentiment < -0.1 else "ğŸŸ¡"
                    st.metric("Avg Sentiment", f"{avg_sentiment:.3f} {sentiment_emoji}")

                with col4:
                    st.metric("Predicted Price", f"â‚¹{predicted_price:.2f}", delta=f"{predicted_return*100:+.2f}%")

                with col5:
                    st.metric("News Articles", len(analyzer.news_articles))

                # Recommendation
                st.markdown("---")
                if predicted_return > 0.02:
                    recommendation = "STRONG BUY"
                    color = "green"
                    emoji = "ğŸŸ¢"
                elif predicted_return > 0:
                    recommendation = "BUY"
                    color = "lightgreen"
                    emoji = "ğŸŸ¢"
                elif predicted_return < -0.02:
                    recommendation = "STRONG SELL"
                    color = "red"
                    emoji = "ğŸ”´"
                elif predicted_return < 0:
                    recommendation = "SELL"
                    color = "orange"
                    emoji = "ğŸ”´"
                else:
                    recommendation = "HOLD"
                    color = "gray"
                    emoji = "ğŸŸ¡"

                col1, col2 = st.columns([2, 1])
                with col1:
                    st.markdown(f"### {emoji} Recommendation: <span style='color:{color}; font-size:32px'>{recommendation}</span>",
                               unsafe_allow_html=True)
                with col2:
                    if test_score is not None:
                        st.info(f"**Model Accuracy (RÂ²):** {test_score:.3f}")
                    else:
                        st.info(f"**Model Accuracy (RÂ²):** {train_score:.3f} (Training)")

                # 20 Recent News Articles
                st.markdown("---")
                st.header("ğŸ“° 20 Most Recent News Articles")

                for idx, article in enumerate(analyzer.news_articles, 1):
                    with st.expander(f"ğŸ“„ Article {idx}: {article.get('title', 'No Title')[:100]}..."):
                        cols = st.columns([3, 1])

                        with cols[0]:
                            st.markdown(f"**Source:** {article.get('source', {}).get('name', 'Unknown')}")
                            st.markdown(f"**Published:** {article.get('publishedAt', 'Unknown')[:10]}")
                            st.markdown(f"**Description:** {article.get('description', 'No description available')}")
                            st.markdown(f"[ğŸ”— Read Full Article]({article.get('url', '#')})")

                        with cols[1]:
                            # Calculate sentiment for this article
                            text = f"{article.get('title', '')} {article.get('description', '')}"
                            sentiment = TextBlob(text).sentiment.polarity

                            if sentiment > 0.1:
                                sent_label = "Positive ğŸ˜Š"
                                sent_color = "green"
                            elif sentiment < -0.1:
                                sent_label = "Negative ğŸ˜Ÿ"
                                sent_color = "red"
                            else:
                                sent_label = "Neutral ğŸ˜"
                                sent_color = "gray"

                            st.markdown(f"**Sentiment:**")
                            st.markdown(f"<span style='color:{sent_color}; font-size:18px'>{sent_label}</span>",
                                       unsafe_allow_html=True)
                            st.markdown(f"**Score:** {sentiment:.3f}")

                # Visualizations
                st.markdown("---")
                st.header("ğŸ“ˆ Interactive Charts")

                fig = make_subplots(
                    rows=3, cols=1,
                    subplot_titles=('Stock Price & Moving Averages', 'News Sentiment Analysis', 'Trading Volume'),
                    vertical_spacing=0.1,
                    row_heights=[0.5, 0.25, 0.25]
                )

                # Price and MA
                fig.add_trace(
                    go.Scatter(x=stock_data.index, y=stock_data['Close'],
                              name='Close Price', line=dict(color='blue', width=2)),
                    row=1, col=1
                )

                # Calculate moving averages only if we have enough data
                if len(stock_data) >= 20:
                    ma20 = stock_data['Close'].rolling(window=20).mean()
                    fig.add_trace(
                        go.Scatter(x=stock_data.index, y=ma20,
                                  name='20-day MA', line=dict(color='orange', dash='dash')),
                        row=1, col=1
                    )

                if len(stock_data) >= 50:
                    ma50 = stock_data['Close'].rolling(window=50).mean()
                    fig.add_trace(
                        go.Scatter(x=stock_data.index, y=ma50,
                                  name='50-day MA', line=dict(color='red', dash='dot')),
                        row=1, col=1
                    )

                # Sentiment
                sentiment_dates = pd.to_datetime(analyzer.news_sentiment['date'])
                colors = ['green' if x > 0 else 'red' for x in analyzer.news_sentiment['sentiment_score']]

                fig.add_trace(
                    go.Bar(x=sentiment_dates, y=analyzer.news_sentiment['sentiment_score'],
                          name='Sentiment', marker_color=colors, showlegend=False),
                    row=2, col=1
                )

                # Volume
                fig.add_trace(
                    go.Bar(x=stock_data.index, y=stock_data['Volume'],
                          name='Volume', marker_color='lightblue', showlegend=False),
                    row=3, col=1
                )

                fig.update_layout(height=900, showlegend=True, hovermode='x unified')
                fig.update_xaxes(title_text="Date", row=3, col=1)
                fig.update_yaxes(title_text="Price (â‚¹)", row=1, col=1)
                fig.update_yaxes(title_text="Sentiment", row=2, col=1)
                fig.update_yaxes(title_text="Volume", row=3, col=1)

                st.plotly_chart(fig, use_container_width=True)

                # Technical indicators
                with st.expander("ğŸ“Š Technical Indicators"):
                    col1, col2, col3, col4 = st.columns(4)

                    df_features = analyzer.prepare_features()

                    if len(df_features) > 0:
                        latest_rsi = df_features['RSI'].iloc[-1] if 'RSI' in df_features.columns else 50
                        latest_vol = df_features['Volatility'].iloc[-1] if 'Volatility' in df_features.columns else 0

                        with col1:
                            st.metric("RSI (14)", f"{latest_rsi:.2f}")
                            if latest_rsi > 70:
                                st.error("Overbought âš ï¸")
                            elif latest_rsi < 30:
                                st.success("Oversold ğŸ’°")
                            else:
                                st.info("Normal ğŸ‘")

                        with col2:
                            st.metric("Volatility (20d)", f"{latest_vol:.4f}")

                        with col3:
                            st.metric("Latest Volume", f"{stock_data['Volume'].iloc[-1]:,.0f}")

                        with col4:
                            if len(stock_data) >= 252:
                                st.metric("52W High", f"â‚¹{stock_data['Close'].tail(252).max():.2f}")
                            else:
                                st.metric("Period High", f"â‚¹{stock_data['Close'].max():.2f}")

        except Exception as e:
            st.error(f"âŒ Error: {str(e)}")
            st.info("ğŸ’¡ Tip: Try selecting a longer date range or a different stock")

    else:
        # Welcome screen
        st.info("ğŸ‘ˆ Select a sector and stock from the sidebar, then click 'Analyze Stock'")

        st.markdown("---")
        col1, col2 = st.columns(2)

        with col1:
            st.markdown("""
            ### ğŸ¯ Features:
            - âœ… Real-time NSE stock data
            - âœ… 20 most recent news articles
            - âœ… Sentiment analysis on news
            - âœ… AI-powered price predictions
            - âœ… Technical indicators
            - âœ… Buy/Sell/Hold recommendations
            - âœ… Interactive visualizations
            """)

        with col2:
            st.markdown("""
            ### ğŸ“Š Available Sectors:
            - ğŸ’» IT & Services
            - ğŸ¦ Banking & Financial Services
            - ğŸ­ Conglomerates & Industrial
            - ğŸ›ï¸ Consumer Goods & Telecom
            - âš¡ Energy & Commodities
            """)

        st.success("ğŸ” Using NewsAPI for real-time news analysis")
        st.warning("âš ï¸ For best results, select a date range of at least 6 months")


if __name__ == "__main__":
    main()